# Copyright (C) 2005-2009 Aaron Bentley and Panometrics, Inc.
#                         Gianluca Montecchi <gian@grys.it>
#                         Oleg Romanyshyn <oromanyshyn@panoramicfeedback.com>
#                         W. Trevor King <wking@drexel.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Define assorted utilities to make command-line handling easier.
"""

import glob
import optparse
import os
from textwrap import TextWrapper
from StringIO import StringIO
import sys

import libbe
import bugdir
import comment
import plugin
import encoding
if libbe.TESTING == True:
    import doctest



def iter_commands():
    for name, module in plugin.iter_plugins("becommands"):
        yield name.replace("_", "-"), module

def execute(cmd, args,
            manipulate_encodings=True, restrict_file_access=False,
            dir="."):
    enc = encoding.get_encoding()
    cmd = get_command(cmd)
    ret = cmd.execute([a.decode(enc) for a in args],
                      manipulate_encodings=manipulate_encodings,
                      restrict_file_access=restrict_file_access,
                      dir=dir)
    if ret == None:
        ret = 0
    return ret




def restrict_file_access(bugdir, path):
    """
    Check that the file at path is inside bugdir.root.  This is
    important if you allow other users to execute becommands with your
    username (e.g. if you're running be-handle-mail through your
    ~/.procmailrc).  If this check wasn't made, a user could e.g.
    run
      be commit -b ~/.ssh/id_rsa "Hack to expose ssh key"
    which would expose your ssh key to anyone who could read the VCS
    log.
    """
    in_root = bugdir.vcs.path_in_root(path, bugdir.root)
    if in_root == False:
        raise UserError('file access restricted!\n  %s not in %s'
                        % (path, bugdir.root))

def parse_id(id):
    """
    Return (bug_id, comment_id) tuple.
    Basically inverts Comment.comment_shortnames()
    >>> parse_id('XYZ')
    ('XYZ', None)
    >>> parse_id('XYZ:123')
    ('XYZ', ':123')
    >>> parse_id('')
    Traceback (most recent call last):
      ...
    UserError: invalid id ''.
    >>> parse_id('::')
    Traceback (most recent call last):
      ...
    UserError: invalid id '::'.
    """
    if len(id) == 0:
        raise UserError("invalid id '%s'." % id)
    if id.count(':') > 1:
        raise UserError("invalid id '%s'." % id)
    elif id.count(':') == 1:
        # Split shortname generated by Comment.comment_shortnames()
        bug_id,comment_id = id.split(':')
        comment_id = ':'+comment_id
    else:
        bug_id = id
        comment_id = None
    return (bug_id, comment_id)

def bug_from_id(bdir, id):
    """
    Exception translation for the command-line interface.
    id can be either the bug shortname or the full uuid.
    """
    try:
        bug = bdir.bug_from_shortname(id)
    except (bugdir.MultipleBugMatches, bugdir.NoBugMatches), e:
        raise UserError(e.message)
    return bug

def bug_comment_from_id(bdir, id):
    """
    Return (bug,comment) tuple matching shortname.  id can be either
    the bug/comment shortname or the full uuid.  If there is no
    comment part to the id, the returned comment is the bug's
    .comment_root.
    """
    bug_id,comment_id = parse_id(id)
    try:
        bug = bdir.bug_from_shortname(bug_id)
    except (bugdir.MultipleBugMatches, bugdir.NoBugMatches), e:
        raise UserError(e.message)
    if comment_id == None:
        comm = bug.comment_root
    else:
        #bug.load_comments(load_full=False)
        try:
            comm = bug.comment_root.comment_from_shortname(comment_id)
        except comment.InvalidShortname, e:
            raise UserError(e.message)
    return (bug, comm)



if libbe.TESTING == True:
    suite = doctest.DocTestSuite()
