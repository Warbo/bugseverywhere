#!/usr/bin/env python
#
# Copyright (C) 2009 W. Trevor King <wking@drexel.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Provide and email interface to the distributed bugtracker Bugs
Everywhere.  Recieves incoming email via procmail and allows users to
select actions with their subject lines.  Subject lines follow the
format
  [be-bug] command (options) (args)
With the body of the email being used as the final argument for the
commands "new" and "comment", and ignored otherwise.  The options and
arguments are split on whitespace, so don't use whitespace inside a
single argument.

Eventually we'll commit after every message.
"""

import codecs
import cStringIO as StringIO
import email
import email.utils
import libbe.cmdutil, libbe.encoding, libbe.utility
import os
import os.path
import send_pgp_mime
import sys
import time
import traceback

SUBJECT_COMMENT = "[be-bug]"
HANDLER_ADDRESS = "BE Bugs <wking@thor.physics.drexel.edu>"
_THIS_DIR = os.path.abspath(os.path.dirname(__file__))
BE_DIR = _THIS_DIR
LOGPATH = os.path.join(_THIS_DIR, "be-handle-mail.log")
LOGFILE = None

libbe.encoding.ENCODING = "utf-8" # force default encoding
ENCODING = libbe.encoding.get_encoding()

ALLOWED_COMMANDS = ["new", "comment", "list", "show", "help"]

class InvalidEmail (ValueError):
    def __init__(self, msg, info, message):
        ValueError.__init__(self, message)
        self.msg = msg
        self.info = info
    def response(self):
        ret = 1
        out_text = None
        return (ret, out_text, self.stderr_msg(), self.info)
    def stderr_msg(self):
        err_text = [u"Invalid email (particular type unknown):\n",
                    unicode(self), u"",
                    send_pgp_mime.flatten(self.msg, to_unicode=True)]
        return u"\n".join(err_text)

class InvalidSubject (InvalidEmail):
    def stderr_msg(self):
        err_text = u"\n".join([u"InvalidSubject:\n",
                               unicode(self), u"",
                               u"full subject was:",
                               self.msg["subject"]])
        return err_text

class InvalidCommand (InvalidEmail):
    def __init__(self, msg, info, command):
        message = "Invalid command '%s'" % command
        InvalidEmail.__init__(self, msg, info, message)
        self.command = command
    def stderr_msg(self):
        err_text = u"\n".join([u"InvalidCommand:\n",
                               unicode(self), u"",
                               u"full subject was:",
                               self.msg["subject"]])
        return err_text

def get_body_type(msg):
    for part in msg.walk():
        if part.is_multipart():
            continue
        return (part.get_payload(decode=1), part.get_content_type())

def run_message(msg_text):
    """
    Attempt to execute the email given in the email string msg_text.
    Raises assorted subclasses of InvalidEmail in the case of invalid
    messages, otherwise return the exit code, stdout, and stderr
    produced by the command, as well as a dictionary of information
    gleaned from the email.
    """
    p=email.Parser.Parser()
    msg=p.parsestr(msg_text)
    
    info = {}
    author = send_pgp_mime.source_email(msg, return_realname=True)
    info["author_name"] = author[0]
    info["author_email"] = author[1]
    info["author_addr"] = email.utils.formataddr(
        (info["author_name"], info["author_email"]))
    info["message-id"] = msg["message-id"]
    if LOGFILE != None:
        LOGFILE.write("handling %s\n" % (info["author_addr"]))
        LOGFILE.write("\n%s\n\n" % msg_text)
    if "subject" not in msg:
        raise InvalidSubject(msg, info, "Email must contain a subject")
    args = msg["subject"].split()
    if len(args) < 1 or args[0] != SUBJECT_COMMENT:
        raise InvalidSubject(
            msg, info, "Subject must start with '%s '" % SUBJECT_COMMENT)
    elif len(args) < 2:
        raise InvalidCommand(msg, info, "") # don't accept blank commands
    command = args[1]
    info["command"] = command
    if command not in ALLOWED_COMMANDS:
        raise InvalidCommand(msg, info, command)
    if len(args) > 2:
        command_args = args[2:]
    else:
        command_args = []
    stdin = None
    if command in ["new", "comment"]:
        body,mime_type = get_body_type(msg)
        if command == "new":
            if "--reporter" not in args and "-r" not in args:
                command_args = ["--reporter", info["author_addr"]]+command_args
            body = body.strip().split("\n", 1)[0] # only take first line
            command_args.append(body)
        elif command == "comment":
            if "--author" not in args and "-a" not in args:
                command_args = ["--author", info["author_addr"]] + command_args
            if "--content-type" not in args and "-c" not in args:
                command_args = ["--content-type", mime_type] + command_args
            if "--alt-id" not in args:
                command_args = ["--alt-id", msg["message-id"]] + command_args
            command_args.append("-")
            stdin = body
    info["command-args"] = command_args
    # set stdin and catch stdout and stderr
    new_stdin = StringIO.StringIO(stdin)
    new_stdout = codecs.getwriter(ENCODING)(StringIO.StringIO())
    new_stderr = codecs.getwriter(ENCODING)(StringIO.StringIO())
    orig_stdin = sys.stdin
    orig_stdout = sys.stdout
    orig_stderr = sys.stderr
    sys.stdin = new_stdin
    sys.stdout = new_stdout
    sys.stderr = new_stderr
    # run the command
    err = None
    os.chdir(BE_DIR)
    try:
        ret = libbe.cmdutil.execute(command, command_args,
                                    manipulate_encodings=False)
    except libbe.cmdutil.GetHelp:
        print libbe.cmdutil.help(command)
    except libbe.cmdutil.GetCompletions:
        err = InvalidCommand(msg, info, "invalid option '--complete'")
    except libbe.cmdutil.UsageError, e:
        err = InvalidCommand(msg, info, e)
    except libbe.cmdutil.UserError, e:
        err = InvalidCommand(msg, info, e)
    # restore stdin, stdout, and stderr
    sys.stdout.flush()
    sys.stderr.flush()
    sys.stdin = orig_stdin
    sys.stdout = orig_stdout
    sys.stderr = orig_stderr
    out_text = codecs.decode(new_stdout.getvalue(), ENCODING)
    err_text = codecs.decode(new_stderr.getvalue(), ENCODING)
    if err != None:
        raise err
    if LOGFILE != None:
        LOGFILE.write(u"stdout? " + str(type(out_text)))
        LOGFILE.write(u"\n%s\n\n" % out_text)
    return (ret, out_text, err_text, info)

def compose_response(ret, out_text, err_text, info):
    if "author_addr" not in info:
        return None
    if "command" not in info:
        info["command"] = u"-BLANK-"
    if "command_args" not in info:
        info["command_args"] = []
    response_header = [u"From: %s" % HANDLER_ADDRESS,
                       u"To: %s" % info["author_addr"],
                       u"Date: %s" % libbe.utility.time_to_str(time.time()),
                       u"Subject: %s Re: %s"%(SUBJECT_COMMENT,info["command"]),
                       ]
    if "message-id" in info:
        response_header.append(u"In-reply-to: %s" % info["message-id"])
    response_body = [u"Results of running: (exit code %d)" % ret,
                     u"  %s %s" % (info["command"],
                                   u" ".join(info["command_args"]))]
    if out_text != None and len(out_text) > 0:
        response_body.extend([u"", u"stdout:", u"", out_text])
    if err_text != None and len(err_text) > 0:
        response_body.extend([u"", u"stderr:", u"", err_text])
    response_body.append(u"") # trailing endline
    response_email = send_pgp_mime.Mail(u"\n".join(response_header),
                                        u"\n".join(response_body))
    if LOGFILE != None:
        LOGFILE.write("responding to %s: %s\n"
                % (info["author_addr"], info["command"]))
        LOGFILE.write("\n%s\n\n"
                      % send_pgp_mime.flatten(response_email.plain(),
                                              to_unicode=True))
    return response_email

def open_logfile(logpath=None):
    """
    If logpath=None, default to global LOGPATH.
    Special logpath strings:
     "-"     set LOGFILE to sys.stderr
     "none"  disable logging
    Relative logpaths are expanded relative to _THIS_DIR
    """
    global LOGPATH, LOGFILE
    if logpath != None:
        if logpath == "-":
            LOGPATH = "stderr"
            LOGFILE = sys.stderr
        elif logpath == "none":
            LOGPATH = "none"
            LOGFILE = None
        elif os.path.isabs(logpath):
            LOGPATH = logpath
        else:
            LOGPATH = os.path.join(_THIS_DIR, logpath)
    if LOGFILE == None and LOGPATH != "none":
        LOGFILE = codecs.open(LOGPATH, "a+", ENCODING)
    LOGFILE.write("Default encoding: %s\n" % ENCODING)

def close_logfile():
    if LOGFILE != None and LOGPATH not in ["stderr", "none"]:
        LOGFILE.close()


def main():
    from optparse import OptionParser

    usage="be-handle-mail [options]\n\n%s" % (__doc__)
    parser = OptionParser(usage=usage)
    parser.add_option('-o', '--output', dest='output', action='store_true',
                      help="Don't mail the generated message, print it to stdout instead.  Useful for testing be-handle-mail functionality without the whole mail transfer agent and procmail setup.")
    parser.add_option('-l', '--logfile', dest='logfile', metavar='LOGFILE',
                      help='Set the logfile to LOGFILE.  Relative paths are relative to the location of this be-handle-mail file (%s).  The special value of "-" directs the log output to stderr, and "none" disables logging.' % _THIS_DIR)

    options,args = parser.parse_args()

    msg_text = sys.stdin.read()
    libbe.encoding.set_IO_stream_encodings(ENCODING) # _after_ reading message
    open_logfile(options.logfile)
    try: 
        ret,out_text,err_text,info = run_message(msg_text)
    except InvalidEmail, e:
        ret,out_text,err_text,info = e.response()
    except Exception, e:
        if LOGFILE != None:
            LOGFILE.write("Uncaught exception:\n%s\n" % (e,))
            traceback.print_tb(sys.exc_traceback, file=LOGFILE)
            close_logfile()
        sys.exit(1)
    response_email = compose_response(ret, out_text, err_text, info).plain()
    if options.output == True:
        print send_pgp_mime.flatten(response_email, to_unicode=True)
    else:
        send_pgp_mime.mail(response_email, send_pgp_mime.sendmail)
    close_logfile()

if __name__ == "__main__":
    main()
