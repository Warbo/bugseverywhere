#!/usr/bin/env python
#
# Copyright (C) 2009 W. Trevor King <wking@drexel.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Provide and email interface to the distributed bugtracker Bugs
Everywhere.  Recieves incoming email via procmail and allows users to
select actions with their subject lines.  Subject lines follow the
format
  [be-bug] command (options) (args)
With the body of the email being used as the final argument for the
commands "new" and "comment", and ignored otherwise.  The options and
arguments are split on whitespace, so don't use whitespace inside a
single argument.
"""

import codecs
import cStringIO as StringIO
import email
from email.mime.multipart import MIMEMultipart
import email.utils
import libbe.cmdutil, libbe.encoding, libbe.utility
import os
import os.path
import send_pgp_mime
import sys
import time
import traceback

SUBJECT_TAG = "[be-bug]"
HANDLER_ADDRESS = "BE Bugs <wking@thor.physics.drexel.edu>"
_THIS_DIR = os.path.abspath(os.path.dirname(__file__))
BE_DIR = _THIS_DIR
LOGPATH = os.path.join(_THIS_DIR, "be-handle-mail.log")
LOGFILE = None

libbe.encoding.ENCODING = "utf-8" # force default encoding
ENCODING = libbe.encoding.get_encoding()

ALLOWED_COMMANDS = ["new", "comment", "list", "show", "help"]

class InvalidEmail (ValueError):
    def __init__(self, msg, message):
        ValueError.__init__(self, message)
        self.msg = msg
    def response(self):
        header = self.msg._response_header
        body = u"Error processing command.\n\n" + self.response_body()
        response_body.append(u"") # trailing endline
        response_generator = \
            send_pgp_mime.PGPMimeMessageFactory(u"\n".join(response_body))
        response = MIMEMultipart()
        response.attach(response_generator.plain())
        response.attach(self.msg)
        return response
    def response_body(self):
        err_text = [u"Invalid email:\n",
                    unicode(self)]
        return u"\n".join(err_text)

class InvalidSubject (InvalidEmail):
    def __init__(self, msg, message=None):
        if message == None:
            message = "Invalid subject"
        InvalidEmail.__init__(self, msg, message)
    def response_body(self):
        err_text = u"\n".join([unicode(self), u"",
                               u"full subject was:",
                               self.msg["subject"]])
        return err_text

class InvalidEmailCommand (InvalidSubject):
    def __init__(self, msg, message=None):
        if message == None:
            message = "Invalid command '%s'" % msg.subject_command()
        InvalidSubject.__init__(self, msg, message)
        self.command = command

class InvalidExecutionCommand (InvalidEmail):
    def __init__(self, msg, command, message=None):
        if message == None:
            message = "Invalid execution command '%s'" % command
        InvalidEmail.__init__(self, msg, message)
        self.command = command

class InvalidOption (InvalidExecutionCommand):
    def __init__(self, msg, option, message=None):
        if message == None:
            message = "Invalid option '%s' to command '%s'" % (option, command)
        InvalidCommand.__init__(self, msg, info, command, message)
        self.option = option


class Command (object):
    """
    A becommands command wrapper.
    Doesn't validate input, so do that before initializing.

    Initialize with
      Command(msg, command, args=None, stdin=None)
    where
      msg:     the Message instance prompting this command
      command: name of becommand to execute, e.g. "new"
      args:    list of arguments to pass to the command
      stdin:   if non-null, a string to pipe into the command's stdin
    """
    def __init__(self, msg, command, args=None, stdin=None):
        self.msg = msg
        self.command = command
        if args == None:
            self.args = []
        else:
            self.args = args
        self.stdin = stdin
        self.ret = None
        self.stdout = None
        self.stdin = None
        self.err = None
    def __str__(self):
        return "<command: %s %s>" % (self.command, " ".join(self.args))
    def run(self):
        """
        Attempt to execute the command whose info is given in the dictionary
        info.  Returns the exit code, stdout, and stderr produced by the
        command.
        """
        assert self.ret == None, "running %s twice!" % str(self)
        # set stdin and catch stdout and stderr
        if self.stdin != None:
            new_stdin = StringIO.StringIO(self.stdin)
            orig___stdin = sys.__stdin__
            sys.__stdin__ = new_stdin
            orig_stdin = sys.stdin
            sys.stdin = new_stdin
        new_stdout = codecs.getwriter(ENCODING)(StringIO.StringIO())
        new_stderr = codecs.getwriter(ENCODING)(StringIO.StringIO())
        orig_stdout = sys.stdout
        orig_stderr = sys.stderr
        sys.stdout = new_stdout
        sys.stderr = new_stderr
        # run the command
        os.chdir(BE_DIR)
        try:
            self.ret = libbe.cmdutil.execute(self.command, self.args,
                                             manipulate_encodings=False)
        except libbe.cmdutil.GetHelp:
            print libbe.cmdutil.help(command)
        except libbe.cmdutil.GetCompletions:
            self.err = InvalidOption(self.msg, self.command, "--complete")
        except libbe.cmdutil.UsageError, e:
            self.err = InvalidCommand(self.msg, self.command, e)
        except libbe.cmdutil.UserError, e:
            self.err = InvalidCommand(self.msg, self.command, e)
        # restore stdin, stdout, and stderr
        if self.stdin != None:
            sys.__stdin__ = new_stdin
            sys.__stdin__ = orig___stdin
            sys.stdin = orig_stdin
        sys.stdout.flush()
        sys.stderr.flush()
        sys.stdout = orig_stdout
        sys.stderr = orig_stderr
        self.stdout = codecs.decode(new_stdout.getvalue(), ENCODING)
        self.stderr = codecs.decode(new_stderr.getvalue(), ENCODING)
        if self.err != None:
            raise self.err
        return (self.ret, self.stdout, self.stderr)
    def response_msg(self):
        response_body = [u"Results of running: (exit code %d)" % self.ret,
                         u"  %s %s" % (self.command, u" ".join(self.args))]
        if self.stdout != None and len(self.stdout) > 0:
            response_body.extend([u"", u"stdout:", u"", self.stdout])
        if self.stderr != None and len(self.stderr) > 0:
            response_body.extend([u"", u"stderr:", u"", self.stderr])
        response_body.append(u"") # trailing endline
        response_generator = \
            send_pgp_mime.PGPMimeMessageFactory(u"\n".join(response_body))
        return response_generator.plain()

class Message (object):
    def __init__(self, email_text):
        self.text = email_text
        p=email.Parser.Parser()
        self.msg=p.parsestr(self.text)
        if LOGFILE != None:
            LOGFILE.write("handling %s\n" % self.author_addr())
            LOGFILE.write("\n%s\n\n" % self.text)
    def author_tuple(self):
        """
        Extract and normalize the sender's email address.  Returns a
        (name, email) tuple.
        """
        if not hasattr(self, "author_tuple_cache"):
            self.author_tuple_cache = \
                send_pgp_mime.source_email(self.msg, return_realname=True)
        return self.author_tuple_cache
    def author_addr(self):
        return email.utils.formataddr(self.author_tuple())
    def author_name(self):
        return self.author_tuple()[0]
    def author_email(self):
        return self.author_tuple()[1]
    def default_msg_attribute_access(self, attr_name, default=None):
        if attr_name in self.msg:
            return self.msg[attr_name]
        return default
    def message_id(self, default=None):
        return self.default_msg_attribute_access("message-id", default=default)
    def subject(self):
        if "subject" not in self.msg:
            raise InvalidSubject(self, "Email must contain a subject")
        return self.msg["subject"]
    def _split_subject(self):
        """
        Returns (tag, command, arg), with missing values replaced by
        None.
        """
        if hasattr(self, "_split_subject_cache"):
            return self._split_subject_cache
        args = self.subject().split()
        if len(args) < 1:
            self._split_subject_cache = (None, None, None)
        elif len(args) < 2:
            self._split_subject_cache = (args[0], None, None)
        elif len(args) > 2:
            self._split_subject_cache = (args[0], args[1], tuple(args[2:]))
        else:
            self._split_subject_cache = (args[0], args[1], tuple())
        return self._split_subject_cache
    def validate_subject(self):
        """
        Validate the subject line as best we can without attempting
        command execution.
        """
        tag,command,args = self._split_subject()
        if tag != SUBJECT_TAG:
            raise InvalidSubject(
                self, "Subject must start with '%s '" % SUBJECT_TAG)
        elif command == None:
            raise InvalidCommand(self, "") # don't accept blank commands
        if command not in ALLOWED_COMMANDS:
            raise InvalidCommand(self, command)
    def subject_command(self):
        tag,command,args = self._split_subject()
        return command
    def subject_args(self):
        tag,command,args = self._split_subject()
        return args
    def _get_bodies_and_mime_types(self):
        """
        Traverse the email message returning (body, mime_type) for
        each non-mulitpart portion of the message.
        """
        for part in self.msg.walk():
            if part.is_multipart():
                continue
            body,mime_type = (part.get_payload(decode=1), part.get_content_type())
            yield (body, mime_type)
    def parse(self):
        """
        Parse the commands given in the email.  Raises assorted
        subclasses of InvalidEmail in the case of invalid messages,
        otherwise returns a list of suggested commands to run.
        """
        self.validate_subject()
        tag,command,args = self._split_subject()
        args = list(args)
        commands = []
        if command == "new":
            body,mime_type = get_bodies_and_mime_types(msg)[0]
            body = body.strip().split("\n", 1)[0] # only take first line
            if "--reporter" not in args and "-r" not in args:
                args = ["--reporter", info["author_addr"]]+args
            args.append(body)
            commands.append(Command(self, command, args))
        elif command == "comment":
            if "--author" not in args and "-a" not in args:
                args = ["--author", info["author_addr"]] + args
            if "--alt-id" not in args:
                args = ["--alt-id", msg["message-id"]] + args
            body,mime_type = get_bodies_and_mime_types(msg)[0]
            if "--content-type" not in args and "-c" not in args:
                args = ["--content-type", mime_type] + args
            args.append("-")
            commands.append(Command(self, command, args, stdin=body))
        else:
            commands.append(Command(self, command, args))
        return commands
    def run(self):
        self._begin_response()
        commands = self.parse()
        for command in commands:
            command.run()
            self._add_response(command.response_msg())
    def _begin_response(self):
        tag,command,args = self._split_subject()
        if args == None:
            args = []
        response_header = [u"From: %s" % HANDLER_ADDRESS,
                           u"To: %s" % self.author_addr(),
                           u"Date: %s" % libbe.utility.time_to_str(time.time()),
                           u"Subject: %s Re: %s %s"%(SUBJECT_TAG, command,
                                                     u"\n".join(args)),
                           ]
        if self.message_id() != None:
            response_header.append(u"In-reply-to: %s" % self.message_id())
        self._response_header = \
            send_pgp_mime.header_from_text(text=u"\n".join(response_header))
        self._response_messages = []
    def _add_response(self, response_message):
        self._response_messages.append(response_message)
    def response_email(self):
        assert len(self._response_messages) > 0
        if len(self._response_messages) == 1:
            ret = send_pgp_mime.attach_root(self._response_header,
                                            self._response_messages[0])
        else:
            ret = MIMEMultipart()
            for message in self._response_messages:
                ret.attach(message)
        return ret

def open_logfile(logpath=None):
    """
    If logpath=None, default to global LOGPATH.
    Special logpath strings:
     "-"     set LOGFILE to sys.stderr
     "none"  disable logging
    Relative logpaths are expanded relative to _THIS_DIR
    """
    global LOGPATH, LOGFILE
    if logpath != None:
        if logpath == "-":
            LOGPATH = "stderr"
            LOGFILE = sys.stderr
        elif logpath == "none":
            LOGPATH = "none"
            LOGFILE = None
        elif os.path.isabs(logpath):
            LOGPATH = logpath
        else:
            LOGPATH = os.path.join(_THIS_DIR, logpath)
    if LOGFILE == None and LOGPATH != "none":
        LOGFILE = codecs.open(LOGPATH, "a+", ENCODING)
        LOGFILE.write("Default encoding: %s\n" % ENCODING)

def close_logfile():
    if LOGFILE != None and LOGPATH not in ["stderr", "none"]:
        LOGFILE.close()


def main():
    from optparse import OptionParser

    usage="be-handle-mail [options]\n\n%s" % (__doc__)
    parser = OptionParser(usage=usage)
    parser.add_option('-o', '--output', dest='output', action='store_true',
                      help="Don't mail the generated message, print it to stdout instead.  Useful for testing be-handle-mail functionality without the whole mail transfer agent and procmail setup.")
    parser.add_option('-l', '--logfile', dest='logfile', metavar='LOGFILE',
                      help='Set the logfile to LOGFILE.  Relative paths are relative to the location of this be-handle-mail file (%s).  The special value of "-" directs the log output to stderr, and "none" disables logging.' % _THIS_DIR)

    options,args = parser.parse_args()

    msg_text = sys.stdin.read()
    libbe.encoding.set_IO_stream_encodings(ENCODING) # _after_ reading message
    open_logfile(options.logfile)
    try:
        m = Message(msg_text)
        m.run()
    except InvalidEmail, e:
        response = e.response()
    except Exception, e:
        if LOGFILE != None:
            LOGFILE.write("Uncaught exception:\n%s\n" % (e,))
            traceback.print_tb(sys.exc_traceback, file=LOGFILE)
            close_logfile()
        sys.exit(1)
    response = m.response_email()
    if options.output == True:
        print send_pgp_mime.flatten(response, to_unicode=True)
    else:
        send_pgp_mime.mail(response, send_pgp_mime.sendmail)
    close_logfile()

if __name__ == "__main__":
    main()
