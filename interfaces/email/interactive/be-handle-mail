#!/usr/bin/env python
#
# Copyright (C) 2009 W. Trevor King <wking@drexel.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""Provide and email interface to the distributed bugtracker Bugs
Everywhere.  Recieves incoming email via procmail and allows users to
select actions with their subject lines.  Subject lines follow the
format
  [be-bug] command (options) (args)
With the body of the email being used as the final argument for the
commands "new" and "comment", and ignored otherwise.  The options and
arguments are split on whitespace, so don't use whitespace inside a
single argument.

Eventually we'll commit after every message.
"""

import cStringIO as StringIO
import email
import email.utils
import libbe.cmdutil, libbe.utility
import os
import os.path
import send_pgp_mime
import sys
import time

SUBJECT_COMMENT = "[be-bug]"
HANDLER_ADDRESS = "BE Bugs <wking@thor.physics.drexel.edu>"
LOGFILE = os.path.join(os.path.dirname(__file__), "be-handle-mail.log")
BE_DIR = os.path.expanduser("~/src/fun/be/be.email")

ALLOWED_COMMANDS = ["new", "comment", "list", "show", "help"]

class InvalidEmail (ValueError):
    def __init__(self, msg, message):
        ValueError.__init__(self, message)
        self.msg = msg

class InvalidSubject (InvalidEmail):
    pass

class InvalidCommand (InvalidEmail):
    def __init__(self, msg, command):
        message = "Invalid command '%s'" % command
        ValueError.__init__(self, msg, message)
        self.command = command

def get_body_type(msg):
    for part in msg.walk():
        if part.is_multipart():
            continue
        return (part.get_payload(decode=1), part.get_content_type())

def run_message(msg_text):
    encoding = libbe.encoding.get_encoding()
    libbe.encoding.set_IO_stream_encodings(encoding)
    
    p=email.Parser.Parser()
    msg=p.parsestr(msg_text)
    
    if "subject" not in msg:
        raise InvalidSubject(msg, "Email must contain a subject")
    author = send_pgp_mime.source_email(msg, return_realname=True)
    author_name = author[0]
    author_email = author[1]
    author_addr = email.utils.formataddr((author_name, author_email))
    if LOGFILE != None:
        f = file(LOGFILE, "w+")
        f.write("handling %s\n" % (author_addr))
        f.write("\n%s\n\n" % msg_text)
        f.close()
    id = msg["message-id"]
    args = msg["subject"].split()
    if len(args) < 1 or args[0] != SUBJECT_COMMENT:
        raise InvalidSubject(msg, "Subject must start with '%s '" % SUBJECT_COMMENT)        
    elif len(args) < 2:
        raise InvalidCommand(msg, "")
    command = args[1]
    if command not in ALLOWED_COMMANDS:
        raise InvalidCommand(msg, command)
    if len(args) > 2:
        command_args = args[2:]
    else:
        command_args = []
    if command in ["new", "comment"]:
        body,type = get_body_type(msg)
        if command == "new":
            if "--reporter" not in args and "-r" not in args:
                command_args = ["--reporter", author_addr] + command_args
            body = body.strip().split("\n", 1)[0] # only take first line
        elif command == "comment":
            if "--author" not in args and "-a" not in args:
                command_args = ["--author", author_addr] + command_args
            if "--content-type" not in args and "-c" not in args:
                command_args = ["--content-type", type] + command_args
            if "--alt-id" not in args:
                command_args = ["--alt-id", msg["message-id"]] + command_args
        command_args.append(body)
    if LOGFILE != None:
        f = file(LOGFILE, "a+")
        f.write("ping\n")
        f.close()
    # catch stdout and stderr
    new_stdout = StringIO.StringIO()
    new_stderr = StringIO.StringIO()
    orig_stdout = sys.stdout
    orig_stderr = sys.stderr
    sys.stdout = new_stdout
    sys.stderr = new_stderr
    # run the command
    os.chdir(BE_DIR)
    ret = libbe.cmdutil.execute(command, command_args)
    # restore stdout and stderr
    sys.stdout.flush()
    sys.stderr.flush()
    sys.stdout = orig_stdout
    sys.stderr = orig_stderr
    out_text = new_stdout.getvalue()
    err_text = new_stderr.getvalue()

    if LOGFILE != None:
        f = file(LOGFILE, "a+")
        f.write("pong\n")
        f.close()
    author_addr = "wking"
    response_header = [u"From: %s" % HANDLER_ADDRESS,
                       u"To: %s" % author_addr,
                       "Date: %s" % libbe.utility.time_to_str(time.time()),
                       "Content-Type: text/plain; charset=%s" % encoding,
                       "Content-Transfer-Encoding: 8bit",
                       "In-reply-to: %s" % (id),
                       u"Subject: %s Re: %s" % (SUBJECT_COMMENT, command),
                       ]
    response_body = [u"Results of running: (exit code %d)" % ret,
                     u"  %s %s" % (command, " ".join(command_args)),
                     u""] # trailing endline on body
    if len(out_text) > 0:
        response_body.extend([u"", u"stdout:", u"", out_text])
    if len(err_text) > 0:
        response_body.extend([u"", u"stderr:", u"", err_text])
    response_body.append(u"")
    response_email = send_pgp_mime.Mail(u"\n".join(response_header),
                                        u"\n".join(response_body))
    if LOGFILE != None:
        f = file(LOGFILE, "a+")
        f.write("responding to %s: %s\n" % (author_addr, command))
        f.write("\n%s\n\n" % send_pgp_mime.flatten(response_email.plain()))
        f.close()
    return response_email

def main():
    msg_text = sys.stdin.read()
    response_email = run_message(msg_text)
    send_pgp_mime.mail(response_email.plain(), send_pgp_mime.sendmail)

if __name__ == "__main__":
    main()
